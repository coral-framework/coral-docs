<!DOCTYPE html>
<html lang='en'>
<head>
<meta content='text/html' http-equiv='Content-Type' />
<title>
Coral 0.5: Fundamentos
</title>
<link href='style/screen.css' media='screen, projection' rel='stylesheet' type='text/css' />
<link href='style/print.css' media='print' rel='stylesheet' type='text/css' />
<!--[if lt IE 8]>
<link href='style/ie.css' media='screen, projection' rel='stylesheet' type='text/css' />
<![endif]-->
<script language='javascript' src='js/column.js' type='text/javascript'></script>
<script language='javascript' src='js/jquery.js' type='text/javascript'></script>
<script language='javascript' src='js/addons.js' type='text/javascript'></script>
</head>
<body class='bp'>
<div id='header'><div id='logotitle'>
<a href='http://doc.libcoral.org/0.5/'>
<h1>Coral Reference Documentation</h1>
</a>
</div>
<div id='navtr'>
<ul>
<li>
<a href='http://libcoral.org/' title='Coral Home'>Coral HOME</a>
</li>
<li class='selected'>
<a href='http://doc.libcoral.org/0.5/' title='Coral Reference Documentation'>DOC</a>
</li>
<li class=''>
<a href='http://doc.libcoral.org/0.5/api/' title='Coral API Documentation'>API</a>
</li>
</ul>
</div>
<div id='versions'>
<ul>
<li>
<a href='http://doc.libcoral.org/0.5/'>
Coral 0.5
<div id='selected'>
<div id='text'>Coral 0.5</div>
</div>
</a>
</li>
<li>
<a href='http://doc.libcoral.org/'>ALL VERSIONS</a>
</li>
</ul>
</div>
</div>
<div id='container'>
<div id='sidebar'><h1>API</h1>

<ul>
<li><a href="api/annotated.html">Class List</a></li>
<li><a href="api/hierarchy.html">Class Hierarchy</a></li>
<li><a href="api/namespaces.html">Namespaces</a></li>
<li><a href="api/group__functional.html">Functional Groups</a></li>
</ul>
<div id='separator'></div>
<h1>Topics</h1>

<ul>
<li><a href="fundamentals.html">Fundamentos</a></li>
<li><a href="types.html">Sistema de Tipos</a></li>
<li><a href="csl.html">Coral Specification Language (CSL)</a></li>
<li><a href="mapping.html">Mapeamento de CSL para C++</a></li>
<li><a href="compiler.html">Compilador</a></li>
<li><a href="cmake.html">CMake Package</a></li>
</ul>
<div id='separator'></div>
<h1>Examples</h1>

<ul>
<li>Tutorial</li>
<li>Examples</li>
</ul>
</div>
<div id='mainarea'>
<div id='toolbar'><div id='breadcrumbs'>
<ul>
<li class='first'>
<a href="./">Home</a>
</li>
<li class='last'>
<span class="active" title="You're here.">Fundamentos</span>
</li>
</ul>
</div>
<div id='docfeedback'>
<a href='https://spreadsheets.google.com/viewform?formkey=dE9TZy1kLTctZ3NBdUd6T2ZBNVBXdmc6MQ&amp;entry_0=fundamentals.html&amp;entry_2=0.5' target='_blank' title='Provide feedback about this documentation page.'>
[+] Documentation Feedback
</a>
</div>
</div>
<div class='doc' id='content'><h1>Fundamentos</h1>

<p>Esta página resume os principais conceitos do Coral, provendo uma visão geral de sua arquitetura.</p>

<h2>Linguagem de Especificação</h2>

<p>A fim de permitir que diferentes linguagens de programação interoperem em um sistema de componentes, é necessário estabelecer um protocolo comum para a representação de dados e a invocação de operações.</p>

<p>Uma maneira de garantir isto é utilizando uma IDL (<em>Interface Definition Language</em>), e mapeamentos da IDL para as linguagens de programação desejadas. Com o auxílio de um compilador IDL, é possível gerar código automático que faz a conversão entre o protocolo específico de uma linguagem de programação e o protocolo comum.</p>

<p>O Coral define a linguagem <em><a href="csl.html">Coral Specification Language (CSL)</a></em>, que se assemelha a uma IDL simples, mas também serve para especificar componentes e "classes nativas" (um conceito específico do Coral). Como o Coral baseia-se no C++, que não provê reflexão em tempo de execução, a infra-estrutura da linguagem CSL também é usada para adicionar suporte à reflexão de tipos.</p>

<h2>Tipos</h2>

<p>No Coral, tipos como enums, structs, interfaces e componentes são definidos em arquivos CSL, seguindo o padrão de nomenclatura <code>NomeDoTipo.csl</code>. Cada arquivo CSL contém a definição de <strong>um único</strong> tipo, cujo nome local deve ser igual ao nome do arquivo desconsiderando-se a extensão <code>.csl</code>.</p>

<p>Os arquivos CSL podem ser organizados hierarquicamente, em diretórios. Por exemplo:</p>

<pre><code>(raiz)
  |
  |- drink/
  |    |- IDrink.csl        - Interface IDrink
  |    |- IJuice.csl        - Interface IJuice, que herda de IDrink
  |    |- ILiquor.csl       - Interface ILiquor, que herda de IDrink
  |    +- liquor/
  |         |- IVodka.csl   - Interface IVodka, que herda de ILiquor
  |         +- IWhisky.csl  - Interface IWhisky, que herda de ILiquor
  |
  |- tasty/
  |    |- Absolut.csl       - Componente Absolut, que implementa IVodka
  |    +- Chivas.csl        - Componente Chivas, que implementa IWhisky
  |
  +- bargain/
</code></pre>

<p>Neste exemplo, a pasta <code>(raiz)</code> define um <strong>repositório de tipos</strong>. As subpastas <code>drink</code>, <code>liquor</code>, <code>tasty</code> e <code>bargain</code> definem <em>namespaces</em>, e finalmente os arquivos <code>.csl</code> definem tipos (no exemplo, interfaces e componentes).</p>

<p>O nome completo de um tipo inclui os namespaces aos quais ele pertence, desde a raiz do repositório, separados por ponto. Por exemplo, o nome completo da interface <code>IVodka</code> seria <code>drink.liquor.IVodka</code>, enquanto que o do componente <code>Absolut</code> seria <code>tasty.Absolut</code>.</p>

<p>A localização de tipos é feita através da variável <code>CORAL_PATH</code>, cujo comportamento é semelhante ao <em>classpath</em> do Java. Se a variável <code>CORAL_PATH</code> indicar mais de uma pasta raiz, o Coral fará as buscas por tipos em múltiplos repositórios &mdash; dando preferência ao repositório que aparecer primeiro na lista, em caso de conflitos.</p>

<h2>Introspecção de Tipos</h2>

<p>O Coral oferece introspecção completa para os tipos que compõem o sistema de componentes &mdash; o que inclui todos os tipos declarados em arquivos <code>.csl</code> que estejam dentro de um repositório de tipos.</p>

<p>A introspecção de um tipo é feita em C++ com o auxílio de um objeto do tipo <code>Type</code>. Todo tipo possui um <code>Type</code>, e todo <code>Type</code> possui identidade de referência. Ou seja, objetos do mesmo tipo compartilham a mesma instância de <code>Type</code>, e é possível comparar se dois objetos são exatamente do mesmo tipo verificando se eles têm o mesmo ponteiro para <code>Type</code>.</p>

<p>Além do <code>Type</code>, cada tipo do Coral é identificado por um <em>nome completo</em> (vide a seção anterior). Em C++, é possível obter o nome de qualquer tipo conhecido, em tempo de compilação, através do operador <code>co::nameOf</code>, como ilustrado abaixo:</p>

<div class="sourcecode cpp"><pre class="hl">
<span class="hl ppc">#include &lt;drink/liquor/IVodka.h&gt;</span>

<span class="hl kwa">using</span> <span class="hl kwf">drink::liquor::IVodka</span><span class="hl opt">;</span>

<span class="hl kwe">std::cout</span> <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">co::nameOf</span><span class="hl opt">&lt;</span><span class="hl kwf">IVodka</span><span class="hl opt">&gt;() &lt;&lt;</span> <span class="hl kwe">std::endl</span><span class="hl opt">;</span>
</pre></div>


<p>O exemplo acima imprimiria:</p>

<pre><code>drink.liquor.IVodka
</code></pre>

<p>Existem duas abordagens básicas para se obter o <code>Type</code> de um tipo. A primeira é baseada numa consulta pelo nome completo do tipo, e pode ser usada em qualquer situação. Por exemplo:</p>

<div class="sourcecode cpp"><pre class="hl">
<span class="hl slc">// Type of interface 'drink.IJuice'</span>
<span class="hl kwf">co::Type</span><span class="hl opt">*</span> t <span class="hl opt">=</span> <span class="hl kwd">co::getType</span><span class="hl opt">(</span> <span class="hl str">&quot;drink.IJuice&quot;</span> <span class="hl opt">);</span>
</pre></div>


<p>A segunda abordagem é mais simples, mas só é possível se o tipo for conhecido em tempo de compilação:</p>

<div class="sourcecode cpp"><pre class="hl">
<span class="hl ppc">#include &lt;drink/IJuice.h&gt;</span>

<span class="hl kwf">co::InterfaceType</span><span class="hl opt">*</span> t <span class="hl opt">=</span> <span class="hl kwd">co::typeOf</span><span class="hl opt">&lt;</span><span class="hl kwf">drink::IJuice</span><span class="hl opt">&gt;();</span>
</pre></div>


<p>Internamente o operador <code>co::typeOf&lt;T&gt;()</code> faz uma busca pelo nome do tipo:</p>

<h2>Gerência de Tipos</h2>

<p>A classe <code>TypeManager</code> é responsável por manter, em tempo de execução, um registro de todos os tipos conhecidos pela aplicação até o momento. Normalmente, um tipo é adicionado ao registro quando é usado pela primeira vez. Na prática, isto pode ocorrer em função dos seguintes eventos:</p>

<ul>
<li><strong>Quando um módulo é carregado</strong>, todos os tipos utilizados pelo módulo, direta ou indiretamente, são verificados e registrados.</li>
<li><strong>Quando o método <code>TypeManager::get( fullName )</code> é chamado</strong>, se o nome especificado for de um tipo desconhecido, o tipo será automaticamente carregado e registrado. O arquivo <code>.csl</code> do tipo deverá estar em algum repositório listado no <code>CORAL_PATH</code>; caso contrário, o método lançará uma exceção.</li>
<li><strong>Quando um novo tipo é definido dinamicamente</strong> através do método <code>co::Namespace::defineType()</code>.</li>
</ul>


<p>Com o auxílio do <code>TypeManager</code> e dos objetos <code>Type</code> é possível listar os métodos e atributos de qualquer tipo, navegar na hierarquia das interfaces conhecidas, e carregar todos os tipos presentes nos repositórios listados no <code>CORAL_PATH</code>.</p>

<p>Uma grande vantagem do modelo de repositório e registro de tipos do Coral é que a introspecção de tipos pode ser feita de forma muito eficiente, sem que nenhuma biblioteca dinâmica seja carregada. A biblioteca onde um tipo está implementado só precisa ser carregada caso o tipo seja instanciado, ou caso seja requerido o uso de reflexão para o tipo.</p>

<h2>Reflexão</h2>

<p>O suporte a programação reflexiva no Coral é o alicerce para inúmeros serviços do sistema de componentes.
O sistema de reflexão, oferecido como uma extensão do sistema de tipos, permite a <strong>manipulação</strong> de tipos e instâncias.</p>

<p>Enquanto que a introspecção de tipos é feita através de objetos do tipo <code>Type</code>, os serviços de reflexão são oferecidos por objetos do tipo <code>Reflector</code>. Alguns exemplos de operações oferecidas pelos <code>Reflector</code>'s são:</p>

<ul>
<li>Instanciação de um tipo.</li>
<li>Obtenção e atribuição de valores para atributos.</li>
<li>Chamadas dinâmicas de métodos de interfaces.</li>
<li>Criação de <em>proxies</em> dinâmicos para interfaces.</li>
</ul>


<p>Diferente do sistema de tipos, que precisa apenas de arquivos <code>.csl</code> para funcionar, o sistema de reflexão requer que as <em>bibliotecas dinâmicas</em> onde os tipos foram implementados estejam carregadas.
Por razões de desempenho, o carregamento de bibliotecas no Coral é feito de forma tardia (<em>lazy</em>). O principal evento que pode causar o carregamento de bibliotecas é justamente a obtenção de um <code>Reflector</code> para um tipo.</p>

<h2>Módulos</h2>

<p>Um módulo é um <strong>pacote de extensão</strong> que adiciona novos tipos, recursos e funcionalidades às aplicações. Os módulos são as unidades de empacotamento e distribuição do Coral. Fisicamente, eles são diretórios; e podem conter bibliotecas dinâmicas, scripts Lua, arquivos CSL, imagens, etc.</p>

<p>Como descrito na seção de Tipos, todo diretório acessível através do <code>CORAL_PATH</code> define um <em>namespace</em>. Por sua vez, todo namespace é <em>potencialmente</em> um módulo. O que determina se um namespace é um módulo ou não é a existência de um <code>ModuleLoader</code> (uma interface) capaz de "carregar" um <code>Module</code> a partir do conteúdo do seu diretório.</p>

<p>Um mesmo módulo pode ser simultaneamente carregado por múltiplos <code>ModuleLoader</code>'s. Caso nenhum <code>ModuleLoader</code> seja capaz de carregar um módulo a partir de um certo diretório, o diretório é considerado apenas um namespace, e não um módulo. O Coral vem com um <code>ModuleLoader</code> padrão capaz de carregar módulos a partir de <em>biblioteca dinâmicas</em>. Neste caso, a biblioteca deve ter o mesmo nome do diretório do módulo.</p>
</div>
</div>
</div>
<div id='footer'><p>
&copy; 2010 libcoral.org. Coral is <a href="https://github.com/libcoral/coral">open source</a>.
See the
<a href='https://github.com/libcoral/coral/blob/master/LICENSE.md'>Coral License</a>
for details.
<br />
Updated on Nov 10 2010.
</p>
</div>
<script type='text/javascript'>
  //<![CDATA[
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-813587-3']);
    _gaq.push(['_setDomainName', 'none']);
    _gaq.push(['_setAllowLinker', true]);
    _gaq.push(['_trackPageview']);
    
    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  //]]>
</script>

</body>

</html>
