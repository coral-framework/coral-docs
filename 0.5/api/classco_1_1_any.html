<!DOCTYPE html>
<html lang='en'>
<head>
<meta content='text/html' http-equiv='Content-Type' />
<title>
Coral 0.5: Current Page
</title>
<link href='../style/screen.css' media='screen, projection' rel='stylesheet' type='text/css' />
<link href='../style/print.css' media='print' rel='stylesheet' type='text/css' />
<!--[if lt IE 8]>
<link href='../style/ie.css' media='screen, projection' rel='stylesheet' type='text/css' />
<![endif]-->
<script language='javascript' src='../js/column.js' type='text/javascript'></script>
<script language='javascript' src='../js/jquery.js' type='text/javascript'></script>
<script language='javascript' src='../js/addons.js' type='text/javascript'></script>
</head>
<body class='bp'>
<div id='header'><div id='logotitle'>
<a href='http://doc.libcoral.org/0.5/'>
<h1>Coral Reference Documentation</h1>
</a>
</div>
<div id='navtr'>
<ul>
<li>
<a href='http://libcoral.org/' title='Coral Home'>Coral HOME</a>
</li>
<li class=''>
<a href='http://doc.libcoral.org/0.5/' title='Coral Reference Documentation'>DOC</a>
</li>
<li class='selected'>
<a href='http://doc.libcoral.org/0.5/api/' title='Coral API Documentation'>API</a>
</li>
</ul>
</div>
<div id='versions'>
<ul>
<li>
<a href='http://doc.libcoral.org/0.5/'>
Coral 0.5
<div id='selected'>
<div id='text'>Coral 0.5</div>
</div>
</a>
</li>
<li>
<a href='http://doc.libcoral.org/'>ALL VERSIONS</a>
</li>
</ul>
</div>
</div>
<div id='container'>
<div id='sidebar'><h1>API</h1>
<ul>
<li>
<a href='annotated.html'>Class List</a>
</li>
<li>
<a href='hierarchy.html'>Class Hierarchy</a>
</li>
<li>
<a href='namespaces.html'>Namespaces</a>
</li>
<li>
<a href='group__functional.html'>Functional Groups</a>
</li>
</ul>
<div id='separator'></div>
<h1>Topics</h1>
<ul>
<li>
<a href='../fundamentals.html'>Fundamentos</a>
</li>
<li>
<a href='../types.html'>Sistema de Tipos</a>
</li>
<li>
<a href='../csl.html'>Coral Specification Language (CSL)</a>
</li>
<li>
<a href='../mapping.html'>Mapeamento de CSL para C++</a>
</li>
<li>
<a href='../compiler.html'>Compilador</a>
</li>
<li>
<a href='../cmake.html'>CMake Package</a>
</li>
</ul>
<div id='separator'></div>
<h1>Examples</h1>
<ul>
<li>Tutorial</li>
<li>Examples</li>
</ul>
</div>
<div id='mainarea'>
<div id='toolbar'><div id='breadcrumbs'>
<ul>
<li class='first'>
<a href="../">Home</a>
</li>
<li><a href='./'>API</a></li><li id='doxtitle'>Any Class Reference</li>
</ul>
</div>
<div id='docfeedback'>
<a href='https://spreadsheets.google.com/viewform?formkey=dE9TZy1kLTctZ3NBdUd6T2ZBNVBXdmc6MQ&amp;entry_0=Any Class Reference&amp;entry_2=0.5' target='_blank' title='Provide feedback about this documentation page.'>
[+] Documentation Feedback
</a>
</div>
</div>
<div class='api' id='content'>
<!-- Generated by Doxygen 1.7.2 -->
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespaceco.html">co</a>      </li>
      <li><a class="el" href="classco_1_1_any.html">Any</a>      </li>
    </ul>
  </div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#related">Related Functions</a>  </div>
  <div class="headertitle">
<h1>Any Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="co::Any" -->
<p>An intermediate representation for variables in the Coral type system, used for reflection.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;co/Any.h&gt;</code></p>

<p><a href="classco_1_1_any-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classco_1_1_any.html#adcfc4878879f0534637410c752c5a31a">VariableFlags</a> { <br/>
&#160;&#160;<a class="el" href="classco_1_1_any.html#adcfc4878879f0534637410c752c5a31aa2ef50ea1d0bddbc3340587bda0266641">VarIsValue</a> =  0, 
<br/>
&#160;&#160;<a class="el" href="classco_1_1_any.html#adcfc4878879f0534637410c752c5a31aa16f20a59f698f2e6e551a144654f41b3">VarIsConst</a> =  1 &lt;&lt; 0, 
<br/>
&#160;&#160;<a class="el" href="classco_1_1_any.html#adcfc4878879f0534637410c752c5a31aa6580a7fa4e2d99fd3e9d48b85e67c109">VarIsPointer</a> =  1 &lt;&lt; 1, 
<br/>
&#160;&#160;<a class="el" href="classco_1_1_any.html#adcfc4878879f0534637410c752c5a31aa03d1ebe0c9c338b48e9dc6bdea94839a">VarIsPointerConst</a> =  1 &lt;&lt; 2, 
<br/>
&#160;&#160;<a class="el" href="classco_1_1_any.html#adcfc4878879f0534637410c752c5a31aa750b55e208a992b541fd6c1cacbcf6f9">VarIsReference</a> =  1 &lt;&lt; 3
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classco_1_1_any.html#af71f9676cc971713894306029ea1e06e">ArrayKind</a> { <br/>
&#160;&#160;<a class="el" href="classco_1_1_any.html#af71f9676cc971713894306029ea1e06ea52a9ce5e6471a4787481c68dddc9ab25">AK_StdVector</a>, 
<br/>
&#160;&#160;<a class="el" href="classco_1_1_any.html#af71f9676cc971713894306029ea1e06eadc603d515a6dd28f1792427ff0b37bd5">AK_RefVector</a>, 
<br/>
&#160;&#160;<a class="el" href="classco_1_1_any.html#af71f9676cc971713894306029ea1e06ea409064f0e7ec34d80af42cbf4a949e8e">AK_ArrayRange</a>
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef __any::State&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classco_1_1_any.html#a9793a412854aea64c53b22ee40c51ec0">State</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="group__platform.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classco_1_1_any.html#a8be4b652948e8c74c7f3a343390f57ab">PseudoVector</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classco_1_1_any.html#a07f7072608d83354a5eed8bbc94ce92b">Any</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classco_1_1_any.html#af04df5a8d13a1232fbef7fd5e00ac025">Any</a> (T var)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classco_1_1_any.html#a36c2b9152794f13075b9cd5ed9cddad1">Any</a> (<a class="el" href="interfaceco_1_1_interface.html">Interface</a> *instance, <a class="el" href="interfaceco_1_1_interface_type.html">InterfaceType</a> *type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classco_1_1_any.html#ae49c12fd51ba18d01c6e8240e378cdb2">Any</a> (<a class="el" href="interfaceco_1_1_type.html">Type</a> *type, <a class="el" href="group__platform.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> flags, void *ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classco_1_1_any.html#a1c27527c5b4ae9dcd153d2f9275dac3f">Any</a> (<a class="el" href="group__coral__enums.html#gab4dd8308e08805aedfe646096be0e4e7">TypeKind</a> kind, <a class="el" href="group__platform.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> flags, void *ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classco_1_1_any.html#a800c2bf927870786699aa176af2eeda6">Any</a> (<a class="el" href="classco_1_1_any.html#af71f9676cc971713894306029ea1e06e">ArrayKind</a> arrayKind, <a class="el" href="interfaceco_1_1_type.html">Type</a> *elementType, <a class="el" href="group__platform.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> flags, void *ptr, std::size_t arraySize=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classco_1_1_any.html#a91c4026dc28de330498ae8d94bc7b55a">Any</a> (const <a class="el" href="classco_1_1_any.html">Any</a> &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classco_1_1_any.html#a74082a1daff91f56146e67cc4e5e7666">~Any</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classco_1_1_any.html#ac8bb3912a3ce86b15842e79d0b421204">clear</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classco_1_1_any.html#a2c0e3d0ded03d53484e1175a489b1b1a">operator==</a> (const <a class="el" href="classco_1_1_any.html">Any</a> &amp;other) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classco_1_1_any.html#a0f2e9d450f8a6d6c0de59bd30ec84b2d">operator!=</a> (const <a class="el" href="classco_1_1_any.html">Any</a> &amp;other) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classco_1_1_any.html">Any</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classco_1_1_any.html#a67a7d162cbd72dba19b0227d0c91d1ef">operator=</a> (const <a class="el" href="classco_1_1_any.html">Any</a> &amp;other)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Variable Introspection</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classco_1_1_any.html#aac1b70a2ed67ead038c4d3f5ac4d8a81">isValid</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__coral__enums.html#gab4dd8308e08805aedfe646096be0e4e7">TypeKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classco_1_1_any.html#af63e8e17f05838719f0271f1af70b72c">getKind</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classco_1_1_any.html#a2a7c98dfb5f8f36cd9c2067bdb43cf38">isConst</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classco_1_1_any.html#af3473c2533a0290038d9b2a670759d7b">isPointer</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classco_1_1_any.html#a6621b18aa9b691eae1ffdc52c6d7d140">isPointerConst</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classco_1_1_any.html#ab7dc8cc872f3cec2e07dace4293989aa">isReference</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceco_1_1_type.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classco_1_1_any.html#a82d6205ae6d49e98a1298a05c215379f">getType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceco_1_1_interface_type.html">InterfaceType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classco_1_1_any.html#a9e060aebf6bdf20fb11893719582428c">getInterfaceType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classco_1_1_any.html#a89d7f5ba7151c50b9afa2e49a91cd07e">getSize</a> () const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classco_1_1_any.html#adf7d2a42944bd9b618b2dc17f8a47202">get</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classco_1_1_any.html#a9793a412854aea64c53b22ee40c51ec0">State</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classco_1_1_any.html#a581d08f4ac9374e95a5e86876cf91753">getState</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classco_1_1_any.html#a9793a412854aea64c53b22ee40c51ec0">State</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classco_1_1_any.html#ac85618ee717f221cb028f13d3f9d07c7">getState</a> () const </td></tr>
<tr><td colspan="2"><div class="groupHeader">Automatic Variable Storage</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classco_1_1_any.html#a2567699d66fa0750bf04213c86a97adf">set</a> (T var)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Custom Variable Storage</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These are alternative versions of <a class="el" href="classco_1_1_any.html#a2567699d66fa0750bf04213c86a97adf">set()</a> that offer manual control over the passed variables.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>These methods are intended for advanced users and should be used with great care. They only contain assertions and do not throw exceptions. Incorrect usage may cause access violations and memory corruption. </dd></dl>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classco_1_1_any.html#af9185d68644d5eacd27156081d04394f">setInterface</a> (<a class="el" href="interfaceco_1_1_interface.html">Interface</a> *instance, <a class="el" href="interfaceco_1_1_interface_type.html">InterfaceType</a> *type=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classco_1_1_any.html#ae102c773e35430e8d24324e553439af6">setVariable</a> (<a class="el" href="interfaceco_1_1_type.html">Type</a> *type, <a class="el" href="group__platform.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> flags, void *ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classco_1_1_any.html#a507d37a75acdec6b6285ec14c7ea6a4e">setBasic</a> (<a class="el" href="group__coral__enums.html#gab4dd8308e08805aedfe646096be0e4e7">TypeKind</a> kind, <a class="el" href="group__platform.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> flags, void *ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classco_1_1_any.html#a4aea995672ed9aa71dedb6f62a4040c4">setArray</a> (<a class="el" href="classco_1_1_any.html#af71f9676cc971713894306029ea1e06e">ArrayKind</a> arrayKind, <a class="el" href="interfaceco_1_1_type.html">Type</a> *elementType, <a class="el" href="group__platform.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> flags, void *ptr, std::size_t size=0)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Output Arguments</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classco_1_1_any.html#a1b053e699ca137769d281bbc7227689e">makeOut</a> (<a class="el" href="interfaceco_1_1_type.html">Type</a> *paramType)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classco_1_1_any.html#ae3c3df18630d41bedff10c8e33b82c87">makeIn</a> ()</td></tr>
<tr><td colspan="2"><div class="groupHeader">Temporary Objects</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>A temporary object is created by calling one of the <em>createXXX()</em> methods. The object will last while its enclosing <a class="el" href="classco_1_1_any.html" title="An intermediate representation for variables in the Coral type system, used for reflection.">co::Any</a> is alive, or until <a class="el" href="classco_1_1_any.html#ae1dc8fc12f0e176b07d3f7407e1e09a2">destroyObject()</a> is called or another temporary object is created. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__coral__enums.html#gab4dd8308e08805aedfe646096be0e4e7">TypeKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classco_1_1_any.html#a1b2db3df3767ca5e9048e2acadf48693">getContainedObjectKind</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classco_1_1_any.html">Any</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classco_1_1_any.html#a383a1da78a9b8c161351c75ad72701d6">createAny</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classco_1_1_any.html#a8dd3afd7fbe2db0a1f3b840f75b6ad00">createString</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classco_1_1_any.html#a8be4b652948e8c74c7f3a343390f57ab">PseudoVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classco_1_1_any.html#ac68babcfa9cc5230948617d326ce82de">createArray</a> (<a class="el" href="interfaceco_1_1_type.html">Type</a> *elementType, size_t n=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classco_1_1_any.html#a8b1b5c846e90c6ea8f2024dc4e4e539e">swapArray</a> (const <a class="el" href="classco_1_1_any.html">Any</a> &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classco_1_1_any.html#a0abe195db02057a32813c08b36e40040">createComplexValue</a> (<a class="el" href="interfaceco_1_1_type.html">Type</a> *type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classco_1_1_any.html#ae1dc8fc12f0e176b07d3f7407e1e09a2">destroyObject</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td colspan="2"><p>(Note that these are not member functions.) </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classco_1_1_any.html#a29315e18907fa8acdc60860b6f3cacf5">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classco_1_1_any.html">co::Any</a> &amp;a)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>An intermediate representation for variables in the Coral type system, used for reflection. </p>
<p>By design, the state of a <a class="el" href="classco_1_1_any.html" title="An intermediate representation for variables in the Coral type system, used for reflection.">co::Any</a> is <em>transient</em>, so its instances <b>should only be allocated on the stack</b>. This class is optimized for use in C++ method signatures (as a parameter or return type) and is <b>unsafe for use as a field type or member variable</b>.</p>
<dl class="user"><dt><b>Supported Features:</b></dt><dd><ul>
<li><a class="el" href="interfaceco_1_1_type.html" title="Basic Type interface.">Type</a> checks, including compliance with type const'ness.</li>
<li>Automatic conversion between primitive values (boolean, arithmetic types and enum).</li>
<li>Type-safe storage and retrieval of pointers and references.</li>
<li>Storage and retrieval of arrays as pointers to <code>std::vectors</code>, <code>co::RefVectors</code> or <code>co::ArrayRanges</code>.</li>
</ul>
</dd></dl>
<dl class="user"><dt><b>What is NOT supported:</b></dt><dd><ul>
<li>Storing exceptions.</li>
<li>Reference counting of interfaces. Stored interface pointers are <b>not</b> considered active references.</li>
</ul>
</dd></dl>
<dl class="user"><dt><b>Values vs. References</b></dt><dd>For efficiency, this class only allows the storage of values for <code>enums</code> and <em>primitive types</em> (i.e. <code>bool</code>, <code>[u]int{8|16|32|64}</code>, <code>float</code> and <code>double</code>). All other types must be stored and retrieved <em>by reference</em> (i.e. either as pointers or actual references), and the programmer must guarantee referred objects outlive their <a class="el" href="classco_1_1_any.html" title="An intermediate representation for variables in the Coral type system, used for reflection.">co::Any</a> instances. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>For variables stored by reference, it is possible to retrieve a pointer even if the passed variable was a reference. However, the opposite (retrieving a reference where a pointer was passed) is <b>not</b> allowed, because the pointer could be NULL. This is not to be confused with retrieving a reference to a pointer (<code>Foo*&amp;</code>), which is allowed if the passed variable was truly a reference to a pointer.</dd></dl>
<dl class="user"><dt><b>Arrays</b></dt><dd>An array can be passed using three possible representations:<ol type="1">
<li>A <code><a class="el" href="classco_1_1_array_range.html" title="An advanced iterator for contiguous arrays of elements.">co::ArrayRange</a></code>, which is the most generic representation but cannot be used to add/remove elements;</li>
<li>A <code>std::vector</code>, which is useful when the receiver needs to add/remove elements to/from the array;</li>
<li>Or a <code><a class="el" href="classco_1_1_ref_vector.html" title="An enhanced std::vector of co::RefPtr&#39;s.">co::RefVector</a></code>, which is similar to a <code>std::vector</code>, but keeps active references to interfaces. </li>
</ol>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>These types are <em>always</em> considered to be <b>mutable</b>. In other words, all arrays passed as <code>std::vectors</code> or <code>co::RefVectors</code> can have their contents changed. To prevent the addition/removal of elements, one should pass the array as a <code><a class="el" href="classco_1_1_array_range.html" title="An advanced iterator for contiguous arrays of elements.">co::ArrayRange</a></code> instead. Moreover, to prevent existing elements from being modified, one should pass a <code><a class="el" href="classco_1_1_array_range.html" title="An advanced iterator for contiguous arrays of elements.">co::ArrayRange</a></code> of <code><b>const</b></code> elements. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>For instance, an array passed as a <code>co::ArrayRange&lt;const std::string&gt;</code> is completely immutable &mdash; as opposed to a <code>std::vector&lt;std::string&gt;</code>, which is fully mutable. Somewhere in between, a <code>co::ArrayRange&lt;std::string&gt;</code> allows existing strings to be modified, but not the array length. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Arrays represented by <code>std::vectors</code> or <code>co::RefVectors</code> must always be passed and retrieved <b>by reference</b>, while <code>co::ArrayRanges</code> must always be passed and retrieved <b>by value</b>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Arrays must generally be retrieved by the exact same type they were passed. However, when retrieving <code>co::ArrayRanges</code> the following coercion rules apply:<ul>
<li>It is possible to retrieve a <code><a class="el" href="classco_1_1_array_range.html" title="An advanced iterator for contiguous arrays of elements.">co::ArrayRange</a>&lt;<em>ValueType&gt;</code></em> from an array passed as a <code>std::vector&lt;<em>ValueType&gt;</code></em>.</li>
<li>It is possible to retrieve a <code><a class="el" href="classco_1_1_array_range.html" title="An advanced iterator for contiguous arrays of elements.">co::ArrayRange</a>&lt;const <em>ValueType&gt;</code></em> from an array passed as either a <code><a class="el" href="classco_1_1_array_range.html" title="An advanced iterator for contiguous arrays of elements.">co::ArrayRange</a>&lt;<em>ValueType&gt;</code></em> or a <code>std::vector&lt;<em>ValueType&gt;</code></em>.</li>
<li>It is possible to retrieve a <code><a class="el" href="classco_1_1_array_range.html" title="An advanced iterator for contiguous arrays of elements.">co::ArrayRange</a>&lt;<em>SuperInterface*</em> const&gt;</code> from an array passed as either a <code><a class="el" href="classco_1_1_array_range.html" title="An advanced iterator for contiguous arrays of elements.">co::ArrayRange</a>&lt;<em>SubInterface*</em> [const]&gt;</code>, a <code>std::vector&lt;<em>SubInterface*&gt;</code></em> or a <code><a class="el" href="classco_1_1_ref_vector.html" title="An enhanced std::vector of co::RefPtr&#39;s.">co::RefVector</a>&lt;<em>SubInterface&gt;</code></em>. </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>Non-listed cases must be retrieved by exact type. In all rules, <code><em>ValueType</code></em> is a Coral value (such as a <code>bool</code> or a <code>struct</code>), optionally passed by reference; and both <code><em>SubInterface</code></em> and <code><em>SuperInterface</code></em> are Coral interfaces, where <code><em>SubInterface</code></em> is a subtype of <code><em>SuperInterface</code></em>, or both are the same interface.</dd></dl>
<dl class="user"><dt><b>Automatic Conversions for Values</b></dt><dd>All types storable as values in a <a class="el" href="classco_1_1_any.html" title="An intermediate representation for variables in the Coral type system, used for reflection.">co::Any</a> can be converted to any other value type. This includes <code>enums</code> and all primitive types (such as <code>bool</code>, integers and floats), and excludes types passed by reference (most notably strings). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Conversion rules are the same applied for <code>static_casts</code> by your C++ compiler. Enums are seen as <code>co::uint32</code> values. However, when converting from a different type, a check is made to ensure the result maps to a valid enum identifier (otherwise, a <a class="el" href="exceptionco_1_1_illegal_cast_exception.html" title="Raised to indicate an invalid casting or conversion.">co::IllegalCastException</a> is raised). </dd></dl>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a9793a412854aea64c53b22ee40c51ec0"></a><!-- doxytag: member="co::Any::State" ref="a9793a412854aea64c53b22ee40c51ec0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef __any::State <a class="el" href="classco_1_1_any.html#a9793a412854aea64c53b22ee40c51ec0">State</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Alias to the struct that contains all info about a <a class="el" href="classco_1_1_any.html" title="An intermediate representation for variables in the Coral type system, used for reflection.">co::Any</a>'s var. </p>

</div>
</div>
<a class="anchor" id="a8be4b652948e8c74c7f3a343390f57ab"></a><!-- doxytag: member="co::Any::PseudoVector" ref="a8be4b652948e8c74c7f3a343390f57ab" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="group__platform.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a>&gt; <a class="el" href="classco_1_1_any.html#a8be4b652948e8c74c7f3a343390f57ab">PseudoVector</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A 'neutral' std::vector type. </p>

</div>
</div>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="adcfc4878879f0534637410c752c5a31a"></a><!-- doxytag: member="co::Any::VariableFlags" ref="adcfc4878879f0534637410c752c5a31a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classco_1_1_any.html#adcfc4878879f0534637410c752c5a31a">VariableFlags</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Flags that can be OR'ed together to describe variables in the Coral type system. For use with the custom variable setters and constructors. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="adcfc4878879f0534637410c752c5a31aa2ef50ea1d0bddbc3340587bda0266641"></a><!-- doxytag: member="VarIsValue" ref="adcfc4878879f0534637410c752c5a31aa2ef50ea1d0bddbc3340587bda0266641" args="" -->VarIsValue</em>&nbsp;</td><td>
<p>Indicates the variable is a simple value. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="adcfc4878879f0534637410c752c5a31aa16f20a59f698f2e6e551a144654f41b3"></a><!-- doxytag: member="VarIsConst" ref="adcfc4878879f0534637410c752c5a31aa16f20a59f698f2e6e551a144654f41b3" args="" -->VarIsConst</em>&nbsp;</td><td>
<p>Indicates the referred value is 'const'. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="adcfc4878879f0534637410c752c5a31aa6580a7fa4e2d99fd3e9d48b85e67c109"></a><!-- doxytag: member="VarIsPointer" ref="adcfc4878879f0534637410c752c5a31aa6580a7fa4e2d99fd3e9d48b85e67c109" args="" -->VarIsPointer</em>&nbsp;</td><td>
<p>Indicates the variable is a pointer. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="adcfc4878879f0534637410c752c5a31aa03d1ebe0c9c338b48e9dc6bdea94839a"></a><!-- doxytag: member="VarIsPointerConst" ref="adcfc4878879f0534637410c752c5a31aa03d1ebe0c9c338b48e9dc6bdea94839a" args="" -->VarIsPointerConst</em>&nbsp;</td><td>
<p>Indicates the pointer is 'const' (implies VarIsPointer). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="adcfc4878879f0534637410c752c5a31aa750b55e208a992b541fd6c1cacbcf6f9"></a><!-- doxytag: member="VarIsReference" ref="adcfc4878879f0534637410c752c5a31aa750b55e208a992b541fd6c1cacbcf6f9" args="" -->VarIsReference</em>&nbsp;</td><td>
<p>Indicates the variable is a reference. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="af71f9676cc971713894306029ea1e06e"></a><!-- doxytag: member="co::Any::ArrayKind" ref="af71f9676cc971713894306029ea1e06e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classco_1_1_any.html#af71f9676cc971713894306029ea1e06e">ArrayKind</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enumeration of the supported array representations in the Coral type system. For use with <a class="el" href="classco_1_1_any.html#a4aea995672ed9aa71dedb6f62a4040c4">setArray()</a> and its corresponding <a class="el" href="classco_1_1_any.html" title="An intermediate representation for variables in the Coral type system, used for reflection.">co::Any</a> constructor. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="af71f9676cc971713894306029ea1e06ea52a9ce5e6471a4787481c68dddc9ab25"></a><!-- doxytag: member="AK_StdVector" ref="af71f9676cc971713894306029ea1e06ea52a9ce5e6471a4787481c68dddc9ab25" args="" -->AK_StdVector</em>&nbsp;</td><td>
<p>Indicates the variable is a <code>std::vector</code>. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af71f9676cc971713894306029ea1e06eadc603d515a6dd28f1792427ff0b37bd5"></a><!-- doxytag: member="AK_RefVector" ref="af71f9676cc971713894306029ea1e06eadc603d515a6dd28f1792427ff0b37bd5" args="" -->AK_RefVector</em>&nbsp;</td><td>
<p>Indicates the variable is a <code><a class="el" href="classco_1_1_ref_vector.html" title="An enhanced std::vector of co::RefPtr&#39;s.">co::RefVector</a></code> (implies VarIsPointerConst). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af71f9676cc971713894306029ea1e06ea409064f0e7ec34d80af42cbf4a949e8e"></a><!-- doxytag: member="AK_ArrayRange" ref="af71f9676cc971713894306029ea1e06ea409064f0e7ec34d80af42cbf4a949e8e" args="" -->AK_ArrayRange</em>&nbsp;</td><td>
<p>Indicates the variable is a <code><a class="el" href="classco_1_1_array_range.html" title="An advanced iterator for contiguous arrays of elements.">co::ArrayRange</a></code>. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a07f7072608d83354a5eed8bbc94ce92b"></a><!-- doxytag: member="co::Any::Any" ref="a07f7072608d83354a5eed8bbc94ce92b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classco_1_1_any.html">Any</a> </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an invalid <a class="el" href="classco_1_1_any.html" title="An intermediate representation for variables in the Coral type system, used for reflection.">co::Any</a>. </p>

</div>
</div>
<a class="anchor" id="af04df5a8d13a1232fbef7fd5e00ac025"></a><!-- doxytag: member="co::Any::Any" ref="af04df5a8d13a1232fbef7fd5e00ac025" args="(T var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classco_1_1_any.html">Any</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"> <em>var</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Template constructor that stores any variable supported by the Coral type system.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Since the template variable <code>T</code> must be inferred by the compiler, this constructor is subject to language limitations that will make it miss the fact that a variable's type is 'const' and/or a reference. Please call <a class="el" href="classco_1_1_any.html#a2567699d66fa0750bf04213c86a97adf">set()</a> instead, passing the variable's type explicitly, if you must store a reference or a 'const' variable. </dd></dl>

</div>
</div>
<a class="anchor" id="a36c2b9152794f13075b9cd5ed9cddad1"></a><!-- doxytag: member="co::Any::Any" ref="a36c2b9152794f13075b9cd5ed9cddad1" args="(Interface *instance, InterfaceType *type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classco_1_1_any.html">Any</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceco_1_1_interface.html">Interface</a> *&#160;</td>
          <td class="paramname"> <em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfaceco_1_1_interface_type.html">InterfaceType</a> *&#160;</td>
          <td class="paramname"> <em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructor corresponding to a <a class="el" href="classco_1_1_any.html#af9185d68644d5eacd27156081d04394f">setInterface()</a> call. Please, see <a class="el" href="classco_1_1_any.html#af9185d68644d5eacd27156081d04394f">setInterface()</a>'s documentation for more info. </p>

</div>
</div>
<a class="anchor" id="ae49c12fd51ba18d01c6e8240e378cdb2"></a><!-- doxytag: member="co::Any::Any" ref="ae49c12fd51ba18d01c6e8240e378cdb2" args="(Type *type, uint32 flags, void *ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classco_1_1_any.html">Any</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceco_1_1_type.html">Type</a> *&#160;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a>&#160;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"> <em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructor corresponding to a <a class="el" href="classco_1_1_any.html#ae102c773e35430e8d24324e553439af6">setVariable()</a> call. Please, see <a class="el" href="classco_1_1_any.html#ae102c773e35430e8d24324e553439af6">setVariable()</a>'s documentation for more info. </p>

</div>
</div>
<a class="anchor" id="a1c27527c5b4ae9dcd153d2f9275dac3f"></a><!-- doxytag: member="co::Any::Any" ref="a1c27527c5b4ae9dcd153d2f9275dac3f" args="(TypeKind kind, uint32 flags, void *ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classco_1_1_any.html">Any</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__coral__enums.html#gab4dd8308e08805aedfe646096be0e4e7">TypeKind</a>&#160;</td>
          <td class="paramname"> <em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a>&#160;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"> <em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructor corresponding to a <a class="el" href="classco_1_1_any.html#a507d37a75acdec6b6285ec14c7ea6a4e">setBasic()</a> call. Please, see <a class="el" href="classco_1_1_any.html#a507d37a75acdec6b6285ec14c7ea6a4e">setBasic()</a>'s documentation for more info. </p>

</div>
</div>
<a class="anchor" id="a800c2bf927870786699aa176af2eeda6"></a><!-- doxytag: member="co::Any::Any" ref="a800c2bf927870786699aa176af2eeda6" args="(ArrayKind arrayKind, Type *elementType, uint32 flags, void *ptr, std::size_t arraySize=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classco_1_1_any.html">Any</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classco_1_1_any.html#af71f9676cc971713894306029ea1e06e">ArrayKind</a>&#160;</td>
          <td class="paramname"> <em>arrayKind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfaceco_1_1_type.html">Type</a> *&#160;</td>
          <td class="paramname"> <em>elementType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a>&#160;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"> <em>arraySize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructor corresponding to a <a class="el" href="classco_1_1_any.html#a4aea995672ed9aa71dedb6f62a4040c4">setArray()</a> call. Please, see <a class="el" href="classco_1_1_any.html#a4aea995672ed9aa71dedb6f62a4040c4">setArray()</a>'s documentation for more info. </p>

</div>
</div>
<a class="anchor" id="a91c4026dc28de330498ae8d94bc7b55a"></a><!-- doxytag: member="co::Any::Any" ref="a91c4026dc28de330498ae8d94bc7b55a" args="(const Any &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classco_1_1_any.html">Any</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classco_1_1_any.html">Any</a> &amp;&#160;</td>
          <td class="paramname"> <em>other</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>

</div>
</div>
<a class="anchor" id="a74082a1daff91f56146e67cc4e5e7666"></a><!-- doxytag: member="co::Any::~Any" ref="a74082a1daff91f56146e67cc4e5e7666" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classco_1_1_any.html">Any</a> </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ac8bb3912a3ce86b15842e79d0b421204"></a><!-- doxytag: member="co::Any::clear" ref="ac8bb3912a3ce86b15842e79d0b421204" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clear </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clears any variable/object stored in the <a class="el" href="classco_1_1_any.html" title="An intermediate representation for variables in the Coral type system, used for reflection.">co::Any</a>. </p>

</div>
</div>
<a class="anchor" id="aac1b70a2ed67ead038c4d3f5ac4d8a81"></a><!-- doxytag: member="co::Any::isValid" ref="aac1b70a2ed67ead038c4d3f5ac4d8a81" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isValid </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether this <a class="el" href="classco_1_1_any.html" title="An intermediate representation for variables in the Coral type system, used for reflection.">co::Any</a> was initialized. </p>

</div>
</div>
<a class="anchor" id="af63e8e17f05838719f0271f1af70b72c"></a><!-- doxytag: member="co::Any::getKind" ref="af63e8e17f05838719f0271f1af70b72c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__coral__enums.html#gab4dd8308e08805aedfe646096be0e4e7">TypeKind</a> getKind </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the kind of variable stored in this object. </p>

</div>
</div>
<a class="anchor" id="a2a7c98dfb5f8f36cd9c2067bdb43cf38"></a><!-- doxytag: member="co::Any::isConst" ref="a2a7c98dfb5f8f36cd9c2067bdb43cf38" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isConst </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether the variable stored in this object is 'const'. </p>

</div>
</div>
<a class="anchor" id="af3473c2533a0290038d9b2a670759d7b"></a><!-- doxytag: member="co::Any::isPointer" ref="af3473c2533a0290038d9b2a670759d7b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isPointer </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether the variable stored in this object is a pointer. </p>

</div>
</div>
<a class="anchor" id="a6621b18aa9b691eae1ffdc52c6d7d140"></a><!-- doxytag: member="co::Any::isPointerConst" ref="a6621b18aa9b691eae1ffdc52c6d7d140" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isPointerConst </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether the variable stored in this object is a pointer and the pointer is const. </p>

</div>
</div>
<a class="anchor" id="ab7dc8cc872f3cec2e07dace4293989aa"></a><!-- doxytag: member="co::Any::isReference" ref="ab7dc8cc872f3cec2e07dace4293989aa" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isReference </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether the variable stored in this object is a reference. </p>

</div>
</div>
<a class="anchor" id="a82d6205ae6d49e98a1298a05c215379f"></a><!-- doxytag: member="co::Any::getType" ref="a82d6205ae6d49e98a1298a05c215379f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceco_1_1_type.html">Type</a>* getType </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For <code>enums</code>, <code>structs</code> and <code>native</code> <code>classes</code>, this returns the <a class="el" href="interfaceco_1_1_type.html" title="Basic Type interface.">co::Type</a> of the stored variable. For <code>arrays</code>, this returns the array element type. For <code>interfaces</code> you should call <a class="el" href="classco_1_1_any.html#a9e060aebf6bdf20fb11893719582428c" title="Returns the co::InterfaceType of the stored interface instance.">getInterfaceType()</a> instead. For all other type kinds, this returns NULL. </p>

</div>
</div>
<a class="anchor" id="a9e060aebf6bdf20fb11893719582428c"></a><!-- doxytag: member="co::Any::getInterfaceType" ref="a9e060aebf6bdf20fb11893719582428c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceco_1_1_interface_type.html">InterfaceType</a>* getInterfaceType </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the <a class="el" href="interfaceco_1_1_interface_type.html" title="Type representing a Coral Interface.">co::InterfaceType</a> of the stored interface instance. </p>

</div>
</div>
<a class="anchor" id="a89d7f5ba7151c50b9afa2e49a91cd07e"></a><!-- doxytag: member="co::Any::getSize" ref="a89d7f5ba7151c50b9afa2e49a91cd07e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> getSize </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the size of the variable stored in this object; or, in the case of arrays, by each array element. This method mimics the behavior of operator sizeof(): for pointers, the result is always sizeof(void*). For references, the result is equivalent to the value's size.</p>
<p>This method may have to use the type's reflector to inquire the size of user-defined types; therefore, it may throw exceptions. </p>

</div>
</div>
<a class="anchor" id="adf7d2a42944bd9b618b2dc17f8a47202"></a><!-- doxytag: member="co::Any::get" ref="adf7d2a42944bd9b618b2dc17f8a47202" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T get </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Attempts to retrieve a stored variable, making the necessary casts whenever possible.</p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="exceptionco_1_1_illegal_cast_exception.html" title="Raised to indicate an invalid casting or conversion.">co::IllegalCastException</a></td><td>if there is no valid cast from the stored variable's type to the requested type <code>T</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a581d08f4ac9374e95a5e86876cf91753"></a><!-- doxytag: member="co::Any::getState" ref="a581d08f4ac9374e95a5e86876cf91753" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classco_1_1_any.html#a9793a412854aea64c53b22ee40c51ec0">State</a>&amp; getState </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides read/write access to the internal state of a <a class="el" href="classco_1_1_any.html" title="An intermediate representation for variables in the Coral type system, used for reflection.">co::Any</a>. </p>

</div>
</div>
<a class="anchor" id="ac85618ee717f221cb028f13d3f9d07c7"></a><!-- doxytag: member="co::Any::getState" ref="ac85618ee717f221cb028f13d3f9d07c7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classco_1_1_any.html#a9793a412854aea64c53b22ee40c51ec0">State</a>&amp; getState </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides read access to the internal state of a <a class="el" href="classco_1_1_any.html" title="An intermediate representation for variables in the Coral type system, used for reflection.">co::Any</a>. </p>

</div>
</div>
<a class="anchor" id="a2567699d66fa0750bf04213c86a97adf"></a><!-- doxytag: member="co::Any::set" ref="a2567699d66fa0750bf04213c86a97adf" args="(T var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"> <em>var</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Automatically stores any variable supported by the Coral type system. Previous contents are discarded.</p>
<p>This method uses template meta-programming to statically infer a variable's type. If you need to set a <a class="el" href="classco_1_1_any.html" title="An intermediate representation for variables in the Coral type system, used for reflection.">co::Any</a> dynamically at runtime, use the "Custom Storage Methods" instead.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>If you don't specify the template variable <code>T</code> explicitly, due to language limitations the compiler will generally miss the fact that a variable's type is 'const' and/or a reference. </dd></dl>

</div>
</div>
<a class="anchor" id="af9185d68644d5eacd27156081d04394f"></a><!-- doxytag: member="co::Any::setInterface" ref="af9185d68644d5eacd27156081d04394f" args="(Interface *instance, InterfaceType *type=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceco_1_1_interface.html">Interface</a> *&#160;</td>
          <td class="paramname"> <em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfaceco_1_1_interface_type.html">InterfaceType</a> *&#160;</td>
          <td class="paramname"> <em>type</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stores an interface pointer.</p>
<p>The <code>type</code> parameter is optional. When it's not passed, the interface type is extracted from the interface instance, which in this case cannot be NULL. Always pass the interface <code>type</code> for cases where the interface instance could be null.</p>
<p>This method does not take variable flags, variables are always pointers. If you want to create a reference to an interface pointer, use <a class="el" href="classco_1_1_any.html#ae102c773e35430e8d24324e553439af6">setVariable()</a> instead. </p>

</div>
</div>
<a class="anchor" id="ae102c773e35430e8d24324e553439af6"></a><!-- doxytag: member="co::Any::setVariable" ref="ae102c773e35430e8d24324e553439af6" args="(Type *type, uint32 flags, void *ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceco_1_1_type.html">Type</a> *&#160;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a>&#160;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"> <em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stores a single-value (non-array) variable.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The variable's type. </td></tr>
    <tr><td class="paramname">flags</td><td>One or more flags from the <code>VariableFlags</code> enum OR'ed together. Please note that when <code>VarIsPointer</code> is specified, <code>ptr</code> should be a pointer to the value, not a pointer to a pointer. </td></tr>
    <tr><td class="paramname">ptr</td><td>The variable instance, which must really be an instance of <code>type</code> and have the modifiers described in <code>flags</code> (otherwise, all hell will break loose). If <code>flags</code> specifies <code>VarIsReference</code>, <code>ptr</code> cannot be null. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a507d37a75acdec6b6285ec14c7ea6a4e"></a><!-- doxytag: member="co::Any::setBasic" ref="a507d37a75acdec6b6285ec14c7ea6a4e" args="(TypeKind kind, uint32 flags, void *ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setBasic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__coral__enums.html#gab4dd8308e08805aedfe646096be0e4e7">TypeKind</a>&#160;</td>
          <td class="paramname"> <em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a>&#160;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"> <em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Alternative version of <a class="el" href="classco_1_1_any.html#ae102c773e35430e8d24324e553439af6">setVariable()</a>, simplified for basic types. Parameter 'kind' must range from co::TK_ANY to co::TK_STRING (i.e. types that are uniquely identified by their co::TypeKind). </p>

</div>
</div>
<a class="anchor" id="a4aea995672ed9aa71dedb6f62a4040c4"></a><!-- doxytag: member="co::Any::setArray" ref="a4aea995672ed9aa71dedb6f62a4040c4" args="(ArrayKind arrayKind, Type *elementType, uint32 flags, void *ptr, std::size_t size=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classco_1_1_any.html#af71f9676cc971713894306029ea1e06e">ArrayKind</a>&#160;</td>
          <td class="paramname"> <em>arrayKind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfaceco_1_1_type.html">Type</a> *&#160;</td>
          <td class="paramname"> <em>elementType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a>&#160;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"> <em>size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stores an array of any kind.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">arrayKind</td><td>The array representation being passed, which affects the expected value of parameter <code>ptr:</code> </p>
<ul>
<li><code>AK_StdVector:</code> <code>ptr</code> should be a pointer to a <code>std::vector</code> instance.</li>
<li><code>AK_RefVector:</code> <code>ptr</code> should be a pointer to a <code><a class="el" href="classco_1_1_ref_vector.html" title="An enhanced std::vector of co::RefPtr&#39;s.">co::RefVector</a></code> instance.</li>
<li><code>AK_ArrayRange:</code> <code>ptr</code> should be a pointer to the first array element, while <code>size</code> should specify the number of elements in the range. </li>
</ul>
</td></tr>
    <tr><td class="paramname">elementType</td><td>The array element type. </td></tr>
    <tr><td class="paramname">flags</td><td>Modifiers for the array elements. </td></tr>
    <tr><td class="paramname">ptr</td><td>A pointer to the array instance, as described above. </td></tr>
    <tr><td class="paramname">size</td><td>Only used if <code>arrayKind</code> is <code>AK_ArrayRange</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1b053e699ca137769d281bbc7227689e"></a><!-- doxytag: member="co::Any::makeOut" ref="a1b053e699ca137769d281bbc7227689e" args="(Type *paramType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void makeOut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceco_1_1_type.html">Type</a> *&#160;</td>
          <td class="paramname"> <em>paramType</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Prepares a <a class="el" href="classco_1_1_any.html" title="An intermediate representation for variables in the Coral type system, used for reflection.">co::Any</a> for use as an 'out' argument of the specified type. If the <a class="el" href="classco_1_1_any.html" title="An intermediate representation for variables in the Coral type system, used for reflection.">co::Any</a> already contains a value, it will be preserved (if it's compatible). Otherwise, a default-constructed, temporary object will be created. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">paramType</td><td>the 'out' parameter type. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classco_1_1_exception.html" title="Base class for all Coral exceptions.">co::Exception</a></td><td>if the <a class="el" href="classco_1_1_any.html" title="An intermediate representation for variables in the Coral type system, used for reflection.">co::Any</a>'s current value is incompatible with 'paramType'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classco_1_1_any.html#ae3c3df18630d41bedff10c8e33b82c87">makeIn()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae3c3df18630d41bedff10c8e33b82c87"></a><!-- doxytag: member="co::Any::makeIn" ref="ae3c3df18630d41bedff10c8e33b82c87" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void makeIn </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Should be used after a call to <a class="el" href="classco_1_1_any.html#a1b053e699ca137769d281bbc7227689e">makeOut()</a>, to return an argument to its 'in' condition. For instance, variables of type <code>co::int8&amp;</code> will be dereferenced to a <code>co::int8</code>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This method does not raise exceptions. </dd></dl>

</div>
</div>
<a class="anchor" id="a1b2db3df3767ca5e9048e2acadf48693"></a><!-- doxytag: member="co::Any::getContainedObjectKind" ref="a1b2db3df3767ca5e9048e2acadf48693" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__coral__enums.html#gab4dd8308e08805aedfe646096be0e4e7">TypeKind</a> getContainedObjectKind </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the kind of temporary object contained in this <a class="el" href="classco_1_1_any.html" title="An intermediate representation for variables in the Coral type system, used for reflection.">co::Any</a>, if any. If <a class="el" href="classco_1_1_any.html#aac1b70a2ed67ead038c4d3f5ac4d8a81" title="Returns whether this co::Any was initialized.">isValid()</a> is true but <a class="el" href="classco_1_1_any.html#a1b2db3df3767ca5e9048e2acadf48693">getContainedObjectKind()</a> is co::TK_NONE, then the <a class="el" href="classco_1_1_any.html" title="An intermediate representation for variables in the Coral type system, used for reflection.">co::Any</a> contains only a reference, not an object instance. </p>

</div>
</div>
<a class="anchor" id="a383a1da78a9b8c161351c75ad72701d6"></a><!-- doxytag: member="co::Any::createAny" ref="a383a1da78a9b8c161351c75ad72701d6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classco_1_1_any.html">Any</a>&amp; createAny </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a temporary <a class="el" href="classco_1_1_any.html" title="An intermediate representation for variables in the Coral type system, used for reflection.">co::Any</a> instance and makes this <a class="el" href="classco_1_1_any.html" title="An intermediate representation for variables in the Coral type system, used for reflection.">co::Any</a> reference it. If the <a class="el" href="classco_1_1_any.html" title="An intermediate representation for variables in the Coral type system, used for reflection.">co::Any</a> contains a variable at the time this method is called, it will be preserved in (moved to) the temporary <a class="el" href="classco_1_1_any.html" title="An intermediate representation for variables in the Coral type system, used for reflection.">co::Any</a> instance. However, the <a class="el" href="classco_1_1_any.html" title="An intermediate representation for variables in the Coral type system, used for reflection.">co::Any</a> must not contain a temporary object, or an exception will be thrown. </p>

</div>
</div>
<a class="anchor" id="a8dd3afd7fbe2db0a1f3b840f75b6ad00"></a><!-- doxytag: member="co::Any::createString" ref="a8dd3afd7fbe2db0a1f3b840f75b6ad00" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; createString </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a temporary std::string instance and makes this <a class="el" href="classco_1_1_any.html" title="An intermediate representation for variables in the Coral type system, used for reflection.">co::Any</a> reference it. </p>

</div>
</div>
<a class="anchor" id="ac68babcfa9cc5230948617d326ce82de"></a><!-- doxytag: member="co::Any::createArray" ref="ac68babcfa9cc5230948617d326ce82de" args="(Type *elementType, size_t n=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classco_1_1_any.html#a8be4b652948e8c74c7f3a343390f57ab">PseudoVector</a>&amp; createArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceco_1_1_type.html">Type</a> *&#160;</td>
          <td class="paramname"> <em>elementType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"> <em>n</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a std::vector (or a <a class="el" href="classco_1_1_ref_vector.html" title="An enhanced std::vector of co::RefPtr&#39;s.">co::RefVector</a>, if <code>elementType</code> is an interface) with <code>n</code> default-constructed elements of type <code>elementType</code>, and sets this <a class="el" href="classco_1_1_any.html" title="An intermediate representation for variables in the Coral type system, used for reflection.">co::Any</a> with a reference to the array. </p>

</div>
</div>
<a class="anchor" id="a8b1b5c846e90c6ea8f2024dc4e4e539e"></a><!-- doxytag: member="co::Any::swapArray" ref="a8b1b5c846e90c6ea8f2024dc4e4e539e" args="(const Any &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void swapArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classco_1_1_any.html">Any</a> &amp;&#160;</td>
          <td class="paramname"> <em>other</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Swaps the temporary std::vector or <a class="el" href="classco_1_1_ref_vector.html" title="An enhanced std::vector of co::RefPtr&#39;s.">co::RefVector</a> contained in this <a class="el" href="classco_1_1_any.html" title="An intermediate representation for variables in the Coral type system, used for reflection.">co::Any</a> (i.e. created with <a class="el" href="classco_1_1_any.html#ac68babcfa9cc5230948617d326ce82de">createArray()</a>) with a std::vector or <a class="el" href="classco_1_1_ref_vector.html" title="An enhanced std::vector of co::RefPtr&#39;s.">co::RefVector</a> of the exact same type contained in another <a class="el" href="classco_1_1_any.html" title="An intermediate representation for variables in the Coral type system, used for reflection.">co::Any</a>. </p>

</div>
</div>
<a class="anchor" id="a0abe195db02057a32813c08b36e40040"></a><!-- doxytag: member="co::Any::createComplexValue" ref="a0abe195db02057a32813c08b36e40040" args="(Type *type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* createComplexValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceco_1_1_type.html">Type</a> *&#160;</td>
          <td class="paramname"> <em>type</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates an instance of the specified complex value <code>type</code>, and makes this <a class="el" href="classco_1_1_any.html" title="An intermediate representation for variables in the Coral type system, used for reflection.">co::Any</a> reference it. </p>

</div>
</div>
<a class="anchor" id="ae1dc8fc12f0e176b07d3f7407e1e09a2"></a><!-- doxytag: member="co::Any::destroyObject" ref="ae1dc8fc12f0e176b07d3f7407e1e09a2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void destroyObject </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calls the appropriate destructors and releases any memory allocated for this <a class="el" href="classco_1_1_any.html" title="An intermediate representation for variables in the Coral type system, used for reflection.">co::Any</a>'s temporary object. </p>

</div>
</div>
<a class="anchor" id="a2c0e3d0ded03d53484e1175a489b1b1a"></a><!-- doxytag: member="co::Any::operator==" ref="a2c0e3d0ded03d53484e1175a489b1b1a" args="(const Any &amp;other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classco_1_1_any.html">Any</a> &amp;&#160;</td>
          <td class="paramname"> <em>other</em>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Equality test operator. </p>

</div>
</div>
<a class="anchor" id="a0f2e9d450f8a6d6c0de59bd30ec84b2d"></a><!-- doxytag: member="co::Any::operator!=" ref="a0f2e9d450f8a6d6c0de59bd30ec84b2d" args="(const Any &amp;other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classco_1_1_any.html">Any</a> &amp;&#160;</td>
          <td class="paramname"> <em>other</em>&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inequality test operator. </p>

</div>
</div>
<a class="anchor" id="a67a7d162cbd72dba19b0227d0c91d1ef"></a><!-- doxytag: member="co::Any::operator=" ref="a67a7d162cbd72dba19b0227d0c91d1ef" args="(const Any &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classco_1_1_any.html">Any</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classco_1_1_any.html">Any</a> &amp;&#160;</td>
          <td class="paramname"> <em>other</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment operator. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a29315e18907fa8acdc60860b6f3cacf5"></a><!-- doxytag: member="co::Any::operator&lt;&lt;" ref="a29315e18907fa8acdc60860b6f3cacf5" args="(std::ostream &amp;out, const co::Any &amp;a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classco_1_1_any.html">co::Any</a> &amp;&#160;</td>
          <td class="paramname"> <em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Prints out the variable type and data stored in a <a class="el" href="classco_1_1_any.html" title="An intermediate representation for variables in the Coral type system, used for reflection.">co::Any</a>. </p>

</div>
</div>
</div>
</div>
</div>
</div>
<div id='footer'><p>
&copy; 2010 libcoral.org. Coral is <a href="https://github.com/libcoral/coral">open source</a>.
See the
<a href='https://github.com/libcoral/coral/blob/master/LICENSE.md'>Coral License</a>
for details.
<br />
Updated on Nov 11 2010.
</p>
</div>
<script type='text/javascript'>
  //<![CDATA[
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-813587-3']);
    _gaq.push(['_setDomainName', 'none']);
    _gaq.push(['_setAllowLinker', true]);
    _gaq.push(['_trackPageview']);
    
    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  //]]>
</script>

</body>

</html>
